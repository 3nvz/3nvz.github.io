<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Auto LAN Probe + Embed (80,443,8080)</title>
<style>
  body{font-family:system-ui,Arial,sans-serif;margin:18px;background:#fff;color:#111}
  h1{font-size:18px;margin-bottom:6px}
  #status{margin-bottom:8px;color:#444}
  #openList{max-height:28vh;overflow:auto;border-top:1px solid #eee;padding-top:8px;margin-bottom:12px}
  .entry{padding:6px 8px;border-radius:6px;background:#f9f9f9;border:1px solid #eee;margin-bottom:6px;display:flex;gap:12px;align-items:center}
  .ip{font-family:monospace}
  .ports{margin-left:auto;color:#0a7;font-weight:700}
  #frames{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:12px}
  .frameCard{border:1px solid #ddd;border-radius:8px;padding:8px;background:#fff;display:flex;flex-direction:column;height:360px}
  .frameHeader{display:flex;align-items:center;gap:8px;margin-bottom:6px}
  .frameHeader .title{font-family:monospace;font-weight:700}
  .frameNote{font-size:13px;color:#666;margin-left:auto}
  iframe{flex:1;border-radius:6px;border:1px solid #ccc}
  button{padding:6px 10px;border-radius:6px;border:1px solid #ccc;background:#fff;cursor:pointer}
  .small{font-size:12px;color:#666;margin-top:6px}
  #spinner{display:inline-block;width:14px;height:14px;border:3px solid #ddd;border-top-color:#333;border-radius:50%;animation:spin 1s linear infinite;vertical-align:middle;margin-right:8px}
  @keyframes spin{from{transform:rotate(0)}to{transform:rotate(360deg)}}
</style>
</head>
<body>
  <h1>Auto LAN Probe → embed reachable hosts</h1>
  <div id="status"><span id="spinner"></span>Starting automatic scan — probing ports 80, 443, 8080. Showing embeds for hosts that respond (limit applied).</div>
  <div class="small">If an iframe shows "Blocked" it likely means the remote host disallows framing (X-Frame/CSP). No bypass attempted.</div>

  <div id="openList" aria-live="polite"></div>
  <div id="frames"></div>

<script>
(async function(){
  // ---------- CONFIG ----------
  const subnets = [
    { base: '10.0.0.0', prefix: 24 },            // 10.0.0.1 - 10.0.0.254
    { base: '192.168.50.0', prefix: 24 },       // your Wi-Fi subnet
    { base: '192.168.56.0', prefix: 24 }        // your other subnet
  ];
  const PORTS = [80, 443, 8080];
  const CONCURRENCY = 120;   // parallel IPs per batch
  const TIMEOUT_MS = 900;
  const PAUSE_MS = 30;
  const MAX_IFRAMES = 12;    // cap how many iframes to create automatically

  // ---------- helpers ----------
  function ipToInt(ip){ return ip.split('.').reduce((a,b)=> (a<<8) + (Number(b)&0xFF), 0) >>> 0; }
  function intToIp(i){ return [(i>>>24)&0xFF, (i>>>16)&0xFF, (i>>>8)&0xFF, i&0xFF].join('.'); }
  function cidrRange(base, prefix){
    const baseInt = ipToInt(base);
    const mask = prefix===0 ? 0 : (~0 << (32 - prefix)) >>> 0;
    const network = baseInt & mask;
    const broadcast = network + (~mask >>> 0);
    const start = network + 1;
    const end = broadcast - 1;
    return { start, end };
  }
  function withTimeout(promise, ms){ return Promise.race([promise, new Promise((_, rej)=> setTimeout(()=>rej(new Error('timeout')), ms))]); }

  async function probeFetch(ip, port, timeoutMs){
    const rnd = Math.floor(Math.random()*1e9);
    const proto = (port === 443) ? 'https' : 'http';
    const url = `${proto}://${ip}:${port}/?__probe=${rnd}`;
    const t0 = performance.now();
    try {
      await withTimeout(fetch(url, { mode: 'no-cors', cache: 'no-store' }), timeoutMs);
      const took = Math.round(performance.now() - t0);
      console.log('probe OK', ip, port, took);
      return { ok:true, took, proto, url };
    } catch (err) {
      // resolved as failure/timeout
      return { ok:false, err: (err && err.message) ? err.message : String(err), proto, url };
    }
  }

  // ---------- UI ----------
  const statusEl = document.getElementById('status');
  const openListEl = document.getElementById('openList');
  const framesEl = document.getElementById('frames');

  function setStatus(txt){
    statusEl.innerHTML = `<span id="spinner" style="display:inline-block;width:14px;height:14px;border:3px solid #ddd;border-top-color:#333;border-radius:50%;animation:spin 1s linear infinite;vertical-align:middle;margin-right:8px"></span>${txt}`;
  }
  function idleStatus(txt){
    const s = document.getElementById('spinner');
    if (s) s.style.display = 'none';
    statusEl.textContent = txt;
  }

  function addOpenLine(ip, port, took){
    const el = document.createElement('div');
    el.className = 'entry';
    el.innerHTML = `<span class="ip">${ip}:${port}</span><span class="ports">${took}ms</span>`;
    openListEl.appendChild(el);
  }

  // create frame card (attempt direct load)
  function createFrameCard(ip, port, proto, url){
    const card = document.createElement('div');
    card.className = 'frameCard';
    const header = document.createElement('div');
    header.className = 'frameHeader';
    const title = document.createElement('div');
    title.className = 'title';
    title.textContent = `${ip}:${port}`;
    const note = document.createElement('div');
    note.className = 'frameNote';
    note.textContent = 'loading...';
    header.appendChild(title);
    header.appendChild(note);

    const frameContainer = document.createElement('div');
    frameContainer.style.flex = '1 1 auto';
    frameContainer.style.display = 'flex';
    frameContainer.style.flexDirection = 'column';

    const iframe = document.createElement('iframe');
    // for https port use https src
    iframe.src = url;
    iframe.loading = 'lazy';
    iframe.style.flex = '1 1 auto';
    iframe.style.minHeight = '200px';
    iframe.sandbox = ''; // no sandbox by default; removing sandbox may allow some pages to operate. adjust as needed.

    // heuristics: if iframe fires load -> success. If error or timeout -> blocked/unknown.
    let settled = false;
    const timeoutHandle = setTimeout(()=> {
      if (settled) return;
      settled = true;
      note.textContent = 'timed out / unknown (may be blocked)';
      note.style.color = '#c60';
    }, 2500); // 2.5s to judge framing

    iframe.addEventListener('load', () => {
      if (settled) return;
      settled = true;
      clearTimeout(timeoutHandle);
      note.textContent = 'loaded (may be cross-origin)';
      note.style.color = '#0a7';
    });
    iframe.addEventListener('error', () => {
      if (settled) return;
      settled = true;
      clearTimeout(timeoutHandle);
      note.textContent = 'error loading (likely blocked)';
      note.style.color = '#c60';
    });

    frameContainer.appendChild(iframe);
    card.appendChild(header);
    card.appendChild(frameContainer);
    framesEl.appendChild(card);

    // give user a direct link if it's blocked to open in new tab
    const linkWrap = document.createElement('div');
    linkWrap.style.marginTop = '6px';
    linkWrap.innerHTML = `<a href="${url}" target="_blank" rel="noreferrer">Open in new tab</a>`;
    card.appendChild(linkWrap);

    return card;
  }

  // ---------- scanning logic ----------
  let checked = 0;
  let hosts = 0;
  let iframeCount = 0;

  async function scanRange(startInt, endInt){
    const totalIPs = endInt - startInt + 1;
    for (let batchStart = startInt; batchStart <= endInt; batchStart += CONCURRENCY){
      const batchEnd = Math.min(batchStart + CONCURRENCY - 1, endInt);
      const batch = [];
      for (let i = batchStart; i <= batchEnd; i++){
        batch.push(i);
      }

      // process batch in parallel
      await Promise.all(batch.map(async (ipInt) => {
        const ip = intToIp(ipInt);
        const responded = [];
        for (const port of PORTS){
          const res = await probeFetch(ip, port, TIMEOUT_MS);
          checked++;
          if (res.ok){
            responded.push({ port, took: res.took, proto: res.proto, url: res.url });
            addOpenLine(ip, port, res.took);
            hosts++;
          }
        }
        // if any responded and we haven't hit iframe cap -> create iframes (one per port) up to MAX_IFRAMES
        if (responded.length){
          for (const r of responded){
            if (iframeCount >= MAX_IFRAMES) break;
            createFrameCard(ip, r.port, r.proto, r.url);
            iframeCount++;
          }
        }
      }));

      setStatus(`Checks: ${checked.toLocaleString()} — hosts found (heuristic): ${hosts} — iframes shown: ${iframeCount}`);
      await new Promise(r=>setTimeout(r, PAUSE_MS));
    }
  }

  // run all subnets automatically
  (async function runAll(){
    setStatus('Scanning selected subnets automatically — this may take a while.');
    for (const s of subnets){
      const { start, end } = cidrRange(s.base, s.prefix);
      setStatus(`Scanning ${s.base}/${s.prefix} — ${ (end-start+1).toLocaleString() } addresses`);
      try {
        await scanRange(start, end);
      } catch (err) {
        console.error('scan error', err);
      }
    }
    idleStatus(`Scan complete — checks: ${checked.toLocaleString()}, hosts (heuristic): ${hosts}. ${iframeCount} iframe(s) embedded (max ${MAX_IFRAMES}).`);
  })();

})();
</script>
</body>
</html>
