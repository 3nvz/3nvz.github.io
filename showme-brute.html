<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Localhost Auto Embed Open Ports + Path Wordlist</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, Arial; margin: 0; background: #f7f7f7; }
    h1 { padding: 12px 18px; background: #222; color: #fff; margin: 0; }
    #status { padding: 10px 18px; color: #444; }
    iframe { width: 100%; height: 400px; border: 1px solid #ddd; margin-bottom: 20px; background: #fff; }
    .loading { opacity: 0.5; }
    .found-meta { padding: 8px 18px; color: #666; font-size: 14px; }
  </style>
</head>
<body>
  <h1>Localhost Open Port + Path Viewer</h1>
  <div id="status">Scanning localhost ports and paths...</div>
  <div id="container"></div>

<script>
(async () => {
  const HOST = '127.0.0.1';
  const TIMEOUT_MS = 900;
  const CONCURRENCY = 50;

  // <-- Edit this inline wordlist as you like (keeps everything in this single HTML file) -->
  const PATHS = [
    'install',
    'admin',
    'setup',
    'login',
    'dashboard',
    'api',
    'apiv2',
    'apiv1',
    'apiv3',
    'config'
  ];
  // -------------------------------------------------------------------------------

  const PORTS = [
    80,443,445,631,1080,1433,1521,1883,2375,3000,
    3306,3389,5000,5432,5601,5900,6379,6380,6443,7000,
    8000,8080,8081,8088,8443,8500,8888,9000,9090,9200,
    9300,9999,11211,27017,50070,50075
  ];

  const status = document.getElementById('status');
  const container = document.getElementById('container');

  function withTimeout(promise, ms) {
    return Promise.race([
      promise,
      new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), ms))
    ]);
  }

  // Try a bare host root check (used to quickly detect if port is responsive at all)
  async function isOpen(port) {
    const url = `http://${HOST}:${port}/?check=${Math.random()}`;
    try {
      await withTimeout(fetch(url, { mode: 'no-cors', cache: 'no-store' }), TIMEOUT_MS);
      return true;
    } catch {
      return false;
    }
  }

  // Try a specific path on a port (returns true if the request didn't timeout / error)
  async function isOpenPath(port, path) {
    const url = `http://${HOST}:${port}/${path.replace(/^\//, '')}?check=${Math.random()}`;
    try {
      await withTimeout(fetch(url, { mode: 'no-cors', cache: 'no-store' }), TIMEOUT_MS);
      return true;
    } catch {
      return false;
    }
  }

  // chunked processing of ports with concurrency; for each responsive port, test the inline PATHS
  async function chunked(ports, concurrency) {
    const found = []; // entries like { port, path }
    for (let i = 0; i < ports.length; i += concurrency) {
      const batch = ports.slice(i, i + concurrency);
      await Promise.all(batch.map(async port => {
        // quick check if the port responds at root — if it doesn't, we can still try paths,
        // but this early check saves a bit of requests in noisy environments
        const rootOk = await isOpen(port).catch(() => false);
        // Try all paths sequentially for this port (keeps per-port request volume reasonable)
        for (const p of PATHS) {
          const ok = await isOpenPath(port, p);
          if (ok) {
            found.push({ port, path: p });
            const frame = document.createElement('iframe');
            frame.src = `http://${HOST}:${port}/${p}`;
            frame.title = `Port ${port} /${p}`;
            container.appendChild(frame);
          }
        }
        // if the port responded at root and no path matched, optionally add a root iframe
        // (uncomment the next block if you want root frames too)
        /*
        if (rootOk && !found.some(e => e.port === port)) {
          found.push({ port, path: '' });
          const frameRoot = document.createElement('iframe');
          frameRoot.src = `http://${HOST}:${port}/`;
          frameRoot.title = `Port ${port} /`;
          container.appendChild(frameRoot);
        }
        */
      }));
      status.textContent = `Scanned ${Math.min(i + concurrency, ports.length)}/${ports.length} ports — found ${found.length} hits`;
      await new Promise(r => setTimeout(r, 50)); // keep UI responsive
    }
    return found;
  }

  const hits = await chunked(PORTS, CONCURRENCY);
  if (hits.length === 0) {
    status.textContent = 'Done. No matching paths found on scanned ports.';
  } else {
    const list = hits.map(h => `${h.port}/${h.path}`).join(', ');
    status.textContent = `Done. Found ${hits.length} matches: ${list}`;
    const meta = document.createElement('div');
    meta.className = 'found-meta';
    meta.textContent = `Embedded ${hits.length} iframe(s) — paths checked: ${PATHS.join(', ')}`;
    container.insertBefore(meta, container.firstChild);
  }
})();
</script>
</body>
</html>
