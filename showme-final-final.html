<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Localhost Auto Embed Open Ports + Path Wordlist</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        body {
            font-family: system-ui, Arial;
            margin: 0;
            background: #f7f7f7;
        }

        h1 {
            padding: 12px 18px;
            background: #222;
            color: #fff;
            margin: 0;
        }

        #status {
            padding: 10px 18px;
            color: #444;
        }

        iframe {
            width: 100%;
            height: 400px;
            border: 1px solid #ddd;
            margin-bottom: 20px;
            background: #fff;
        }

        .loading {
            opacity: 0.5;
        }

        .found-meta {
            padding: 8px 18px;
            color: #666;
            font-size: 14px;
        }
    </style>
</head>

<body>
    <h1>Localhost Open Port + Path Viewer</h1>
    <div id="status">Scanning localhost ports and paths...</div>
    <div id="container"></div>

    <script>
        (async () => {
            const HOST = '127.0.0.1';
            const TIMEOUT_MS = 900;
            const CONCURRENCY = 50;

            // <-- Edit this inline wordlist as you like (keeps everything in this single HTML file) -->
            const PATHS = [
                'accelerate','Accelerate','acquire','Acquire','activate','Activate','adapt','Adapt','add','Add',
                'adjust','Adjust','admin','Admin','alert','Alert','annotate','Annotate','anticipate','Anticipate',
                'apply','Apply','arrange','Arrange','build','Build','calculate','Calculate','change','Change',
                'claim','Claim','collect','Collect','com','Com','comm','Comm','communicate','Communicate',
                'compare','Compare','complete','Complete','compose','Compose','compute','Compute','consolidate','Consolidate',
                'construct','Construct','contact','Contact','create','Create','crush','Crush','damage','Damage',
                'def','Def','define','Define','del','Del','delete','Delete','deliver','Deliver',
                'demo','Demo','demonstrate','Demonstrate','dequeue','Dequeue','derive','Derive','design','Design',
                'destroy','Destroy','detect','Detect','dev','Dev','develop','Develop','devise','Devise',
                'disable','Disable','display','Display','divide','Divide','do','Do','doFor','Dofor',
                'doUntil','Dountil','doWhile','Dowhile','download','Download','edit','Edit','enable','Enable',
                'explode','Explode','export','Export','fabricate','Fabricate','fashion','Fashion','fetch','Fetch',
                'for','For','forge','Forge','form','Form','function','Function','gen','Gen',
                'generate','Generate','get','Get','go','Go','group','Group','head','Head',
                'improve','Improve','inform','Inform','inquiry','Inquiry','interpret','Interpret','kill','Kill',
                'level','Level','link','Link','list','List','make','Make','map','Map',
                'mod','Mod','multi','Multi','multiply','Multiply','options','Options','originate','Originate',
                'picture','Picture','post','Post','preserve','Preserve','produce','Produce','promote','Promote',
                'put','Put','queue','Queue','quit','Quit','reactivate','Reactivate','read','Read',
                'recite','Recite','record','Record','register','Register','remove','Remove','restore','Restore',
                'restrict','Restrict','retrieve','Retrieve','run','Run','select','Select','set','Set',
                'setup','Setup','show','Show','sleep','Sleep','sort','Sort','split','Split',
                'start','Start','stop','Stop','study','Study','sub','Sub','subtract','Subtract',
                'terminate','Terminate','test','Test','understand','Understand','undo','Undo','unqueue','Unqueue',
                'until','Until','update','Update','upgrade','Upgrade','upload','Upload','upset','Upset',
                'validate','Validate','verify','Verify','while','While','wreck','Wreck','zap','Zap','api','apiv1','apiv2','apiv2'
            ];
            // -------------------------------------------------------------------------------

            const PORTS = [
                80, 443, 445, 631, 1080, 1433, 1521, 1883, 2375, 3000,
                3306, 3389, 5000, 5432, 5601, 5900, 6379, 6380, 6443, 7000,
                8000, 8080, 8081, 8088, 8443, 8500, 8888, 9000, 9090, 9200,
                9300, 9999, 11211, 27017, 50070, 50075
            ];

            const status = document.getElementById('status');
            const container = document.getElementById('container');

            function withTimeout(promise, ms) {
                return Promise.race([
                    promise,
                    new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), ms))
                ]);
            }

            // Try a bare host root check (used to quickly detect if port is responsive at all)
            async function isOpen(port) {
                const url = `http://${HOST}:${port}/?check=${Math.random()}`;
                try {
                    await withTimeout(fetch(url, { mode: 'no-cors', cache: 'no-store' }), TIMEOUT_MS);
                    return true;
                } catch {
                    return false;
                }
            }

            // Try a specific path on a port and verify it's not a 404.
            // We attempt a HEAD first (lightweight), fall back to GET if needed.
            async function isOpenPath(port, path) {
                const baseUrl = `http://${HOST}:${port}/${path.replace(/^\//, '')}`;
                const url = `${baseUrl}?_=${Math.random()}`;

                // small helper to perform fetch with abort timeout
                async function fetchWithTimeout(input, init = {}) {
                    const controller = new AbortController();
                    const timer = setTimeout(() => controller.abort(), TIMEOUT_MS);
                    try {
                        const res = await fetch(input, { ...init, signal: controller.signal, cache: 'no-store' });
                        clearTimeout(timer);
                        return res;
                    } catch (err) {
                        clearTimeout(timer);
                        throw err;
                    }
                }

                try {
                    // try HEAD first (many servers support it; cheaper than GET)
                    let res = await fetchWithTimeout(url, { method: 'HEAD' });
                    // If server responded 404 -> definitely skip
                    if (res.status === 404) return false;
                    // If HEAD returned 200-399 treat as present
                    if (res.ok || (res.status >= 200 && res.status < 400)) return true;
                    // Some servers reject HEAD with 405/501 — fall back to GET in that case
                    if (res.status === 405 || res.status === 501) {
                        res = await fetchWithTimeout(url, { method: 'GET' });
                        return res.status !== 404;
                    }
                    // For other status codes, treat as present unless it's 404
                    return res.status !== 404;
                } catch (err) {
                    // fetch failed (timeout, CORS, network). In that case we conservatively return false
                    // because we don't want to iframe when the resource is unreachable or blocked.
                    return false;
                }
            }

            // chunked processing of ports with concurrency; for each responsive port, test the inline PATHS
            async function chunked(ports, concurrency) {
                const found = []; // entries like { port, path }
                for (let i = 0; i < ports.length; i += concurrency) {
                    const batch = ports.slice(i, i + concurrency);
                    await Promise.all(batch.map(async port => {
                        // quick check if the port responds at root — if it doesn't, we can still try paths,
                        // but this early check saves a bit of requests in noisy environments
                        const rootOk = await isOpen(port).catch(() => false);
                        let iframeCreatedForPort = false;

                        // If the port root is OK, create a root iframe right away (as requested)
                        if (rootOk) {
                            // create root iframe for this port
                            found.push({ port, path: '' });
                            const frameRoot = document.createElement('iframe');
                            frameRoot.src = `http://${HOST}:${port}/`;
                            frameRoot.title = `Port ${port} /`;
                            container.appendChild(frameRoot);
                            iframeCreatedForPort = true;
                        }

                        // Try all paths sequentially for this port (keeps per-port request volume reasonable)
                        for (const p of PATHS) {
                            // If we've already created a root iframe for this port, we still may want to
                            // check specific paths and embed them as well — keep current behavior.
                            const ok = await isOpenPath(port, p);
                            if (ok) {
                                found.push({ port, path: p });
                                const frame = document.createElement('iframe');
                                frame.src = `http://${HOST}:${port}/${p}`;
                                frame.title = `Port ${port} /${p}`;
                                container.appendChild(frame);
                            }
                        }

                        // (No separate fallback required — root iframe already handled above if responsive)
                    }));
                    status.textContent = `Scanned ${Math.min(i + concurrency, ports.length)}/${ports.length} ports — found ${found.length} hits`;
                    await new Promise(r => setTimeout(r, 50)); // keep UI responsive
                }
                return found;
            }

            const hits = await chunked(PORTS, CONCURRENCY);
            if (hits.length === 0) {
                status.textContent = 'Done. No matching paths found on scanned ports.';
            } else {
                const list = hits.map(h => `${h.port}/${h.path}`).join(', ');
                status.textContent = `Done. Found ${hits.length} matches: ${list}`;
                const meta = document.createElement('div');
                meta.className = 'found-meta';
                meta.textContent = `Embedded ${hits.length} iframe(s) — paths checked: ${PATHS.join(', ')}`;
                container.insertBefore(meta, container.firstChild);
            }
        })();
    </script>
</body>

</html>
